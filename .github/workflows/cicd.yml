name: CineReads CI/CD

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

permissions:
  contents: read
  packages: write

env:
  REGISTRY: ghcr.io

jobs:
  build_test_scan_push:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Compute lowercase owner
        id: vars
        run: echo "owner_lc=${GITHUB_REPOSITORY_OWNER,,}" >> "$GITHUB_OUTPUT"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build & push backend
        uses: docker/build-push-action@v6
        with:
          context: .
          file: docker/Dockerfile.backend
          push: true
          tags: |
            ghcr.io/${{ steps.vars.outputs.owner_lc }}/cinereads-backend:latest
            ghcr.io/${{ steps.vars.outputs.owner_lc }}/cinereads-backend:${{ github.sha }}
          cache-from: type=registry,ref=ghcr.io/${{ steps.vars.outputs.owner_lc }}/cinereads-backend:latest
          cache-to: type=inline

      - name: Build & push frontend
        uses: docker/build-push-action@v6
        with:
          context: .
          file: docker/Dockerfile.frontend
          push: true
          tags: |
            ghcr.io/${{ steps.vars.outputs.owner_lc }}/cinereads-frontend:latest
            ghcr.io/${{ steps.vars.outputs.owner_lc }}/cinereads-frontend:${{ github.sha }}
          cache-from: type=registry,ref=ghcr.io/${{ steps.vars.outputs.owner_lc }}/cinereads-frontend:latest
          cache-to: type=inline

      - name: Smoke test backend image
        run: docker run --rm ghcr.io/${{ steps.vars.outputs.owner_lc }}/cinereads-backend:${{ github.sha }} uvicorn --version

      - name: Smoke test frontend image
        run: docker run --rm ghcr.io/${{ steps.vars.outputs.owner_lc }}/cinereads-frontend:${{ github.sha }} nginx -v || true

  deploy:
    needs: build_test_scan_push
    runs-on: ubuntu-latest
    steps:
      - name: Checkout (for deploy files)
        uses: actions/checkout@v4

      - name: Compute lowercase owner
        id: vars
        run: echo "owner_lc=${GITHUB_REPOSITORY_OWNER,,}" >> "$GITHUB_OUTPUT"

      - name: Show workspace
        run: |
          echo "== pwd =="; pwd
          echo "== root files =="; ls -la
          echo "== deploy/ =="; ls -la deploy || true
          echo "== print first lines =="
          head -n 5 docker-compose.prod.yml || true
          head -n 5 fetch_env.sh || true

      - name: Check deploy files exist
        shell: bash
        run: |
          set -e
          for f in docker-compose.prod.yml deploy/nginx.conf fetch_env.sh; do
            if [ ! -s "$f" ]; then
              echo "::error file=$f::Missing or empty deploy file: $f"
              exit 1
            fi
          done

      # Use single-line, comma-separated source
      - name: Deploy to EC2 over SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script_stop: true
          timeout: 120s
          script: |
            set -euxo pipefail
            sudo mkdir -p /opt/cinereads
            sudo chown -R $USER:$USER /opt/cinereads
            cd /opt/cinereads

            # --- safety nets: recreate compose/nginx if missing ---
            if [ ! -s docker-compose.prod.yml ]; then
              cat > docker-compose.prod.yml <<'YML'
            services:
              backend:
                image: ${BACKEND_IMAGE}
                container_name: cinereads-backend
                env_file:
                  - .env
                environment:
                  UVICORN_APP: "app.main:app"
                restart: unless-stopped
                healthcheck:
                  test: ["CMD", "curl", "-fsS", "http://localhost:8000/health"]
                  interval: 30s
                  timeout: 5s
                  retries: 3
              frontend:
                image: ${FRONTEND_IMAGE}
                container_name: cinereads-frontend
                depends_on:
                  backend:
                    condition: service_healthy
                ports:
                  - "80:80"
                restart: unless-stopped
            YML
            fi

            if [ ! -s deploy/nginx.conf ]; then
              mkdir -p deploy
              cat > deploy/nginx.conf <<'NGX'
            server {
              listen 80;
              server_name _;
              root /usr/share/nginx/html;
              location / { try_files $uri $uri/ /index.html; }
              location /api/ {
                proxy_pass http://cinereads-backend:8000/;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_http_version 1.1;
              }
            }
            NGX
            fi

            # --- ALWAYS overwrite fetch_env.sh so old '/cinereads/prod' logic can't linger ---
            cat > fetch_env.sh <<'EOS'
            #!/usr/bin/env bash
            set -euo pipefail
            PREFIX="${PARAM_PREFIX:-/cinereads}"
            echo "Fetching parameters under ${PREFIX}"

            getp() {
              aws ssm get-parameter --name "$1" --with-decryption --query 'Parameter.Value' --output text
            }

            # sanity check that first param exists to fail fast with a clear message
            if ! getp "${PREFIX}/OPENAI_API_KEY" >/dev/null 2>&1; then
              echo "❌ Could not read ${PREFIX}/OPENAI_API_KEY from SSM. Check IAM role & Parameter Store path."
              exit 1
            fi

            cat > .env <<EOF
            OPENAI_API_KEY=$(getp ${PREFIX}/OPENAI_API_KEY)
            HARDCOVER_API_KEY=$(getp ${PREFIX}/HARDCOVER_API_KEY)
            CACHE_DIR=cache
            CACHE_EXPIRE_SECONDS=3600
            BOOK_CACHE_EXPIRE_SECONDS=86400
            MAX_MOVIES_PER_REQUEST=5
            GPT_MAX_TOKENS=800
            GPT_TEMPERATURE=0.7
            DEBUG=false
            EOF

            echo ".env written with values from ${PREFIX}"
            EOS
            chmod +x fetch_env.sh

            # ensure awscli exists
            if ! command -v aws >/dev/null 2>&1; then
              curl -fsSL https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip -o /tmp/awscliv2.zip
              unzip -q /tmp/awscliv2.zip -d /tmp
              sudo /tmp/aws/install || true
            fi

            # login to GHCR if needed
            if [ -n "${{ secrets.GHCR_PAT }}" ]; then
              echo "${{ secrets.GHCR_PAT }}" | docker login ghcr.io -u ${{ github.repository_owner }} --password-stdin
            fi

            # image tags for compose
            printf 'BACKEND_IMAGE=%s\n'  "ghcr.io/${{ github.repository_owner }}/cinereads-backend:${{ github.sha }}" > .env.docker
            printf 'FRONTEND_IMAGE=%s\n' "ghcr.io/${{ github.repository_owner }}/cinereads-frontend:${{ github.sha }}" >> .env.docker
            echo "=== .env.docker ==="; cat .env.docker

            # use the correct SSM prefix
            PARAM_PREFIX=/cinereads ./fetch_env.sh
            echo "=== .env (first lines) ==="; head -n 5 .env || true

            docker compose -f docker-compose.prod.yml --env-file .env.docker pull
            docker compose -f docker-compose.prod.yml --env-file .env.docker up -d
            docker ps
